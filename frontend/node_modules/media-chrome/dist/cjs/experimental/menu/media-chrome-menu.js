var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var media_chrome_menu_exports = {};
__export(media_chrome_menu_exports, {
  Attributes: () => Attributes,
  MediaChromeMenu: () => MediaChromeMenu,
  createIndicator: () => createIndicator,
  createMenuItem: () => createMenuItem,
  default: () => media_chrome_menu_default
});
module.exports = __toCommonJS(media_chrome_menu_exports);
var import_constants = require("../../constants.js");
var import_server_safe_globals = require("../../utils/server-safe-globals.js");
var import_anchor_utils = require("../../utils/anchor-utils.js");
var import_resize_observer = require("../../utils/resize-observer.js");
var import_element_utils = require("../../utils/element-utils.js");
var _mediaController, _previouslyFocused, _invokerElement, _keysSoFar, _clearKeysTimeout, _metaPressed, _updateLayoutStyle, updateLayoutStyle_fn, _handleInvoke, handleInvoke_fn, _handleOpen, handleOpen_fn, _handleClosed, handleClosed_fn, _updateMenuPosition, _handleKeyUp, handleKeyUp_fn, _handleKeyDown, handleKeyDown_fn, _handleKeyListener, handleKeyListener_fn, _getItem, getItem_fn, _selectItem, selectItem_fn, _handleClick, handleClick_fn, _handleFocusOut, handleFocusOut_fn, _searchItem, searchItem_fn, _clearKeysOnDelay, clearKeysOnDelay_fn;
const checkIcon = `
<svg aria-hidden="true" viewBox="0 1 24 24" part="checked-indicator indicator">
  <path d="m10 15.17 9.193-9.191 1.414 1.414-10.606 10.606-6.364-6.364 1.414-1.414 4.95 4.95Z"/>
</svg>`;
function createMenuItem({ type, text, value, checked }) {
  const item = import_server_safe_globals.document.createElement("media-chrome-menu-item");
  item.type = type != null ? type : "";
  item.part.add("menu-item");
  if (type)
    item.part.add(type);
  item.value = value;
  item.checked = checked;
  const label = import_server_safe_globals.document.createElement("span");
  label.textContent = text;
  item.append(label);
  return item;
}
function createIndicator(el, name) {
  let customIndicator = el.querySelector(`:scope > [slot="${name}"]`);
  if ((customIndicator == null ? void 0 : customIndicator.nodeName) == "SLOT")
    customIndicator = customIndicator.assignedElements({ flatten: true })[0];
  if (customIndicator) {
    customIndicator = customIndicator.cloneNode(true);
    customIndicator.removeAttribute("slot");
    return customIndicator;
  }
  let fallbackIndicator = el.shadowRoot.querySelector(`[name="${name}"] > svg`);
  return fallbackIndicator.cloneNode(true);
}
const template = import_server_safe_globals.document.createElement("template");
template.innerHTML = `
  <style>
    :host {
      font: var(--media-font,
        var(--media-font-weight, normal)
        var(--media-font-size, 15px) /
        var(--media-text-content-height, var(--media-control-height, 24px))
        var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));
      color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
      background: var(--media-menu-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .8))));
      border-radius: var(--media-menu-border-radius);
      border: var(--media-menu-border, none);
      display: var(--media-menu-display, inline-flex);
      opacity: var(--media-menu-opacity, 1);
      max-height: var(--media-menu-max-height, var(--_max-height, 300px));
      visibility: var(--media-menu-visibility, visible);
      transition: var(--media-menu-transition-in,
        visibility 0s, transform .15s ease-out, opacity .15s ease-out);
      transform: var(--media-menu-transform-in, translateY(0) scale(1));
      flex-direction: column;
      ${""}
      min-height: 0;
      position: relative;
      box-sizing: border-box;
    }

    :host([hidden]) {
      opacity: var(--media-menu-hidden-opacity, 0);
      max-height: var(--media-menu-hidden-max-height, var(--media-menu-max-height, var(--_max-height, 300px)));
      visibility: var(--media-menu-hidden-visibility, hidden);
      transition: var(--media-menu-transition-out,
        visibility .15s ease-out, transform .15s ease-out, opacity .15s ease-out);
      transform: var(--media-menu-transform-out, translateY(2px) scale(.99));
      pointer-events: none;
    }

    ::slotted([slot="header"]) {
      padding: .4em 1.4em;
      border-bottom: 1px solid rgb(255 255 255 / .25);
    }

    #container {
      gap: var(--media-menu-gap);
      flex-direction: var(--media-menu-flex-direction, column);
      overflow: var(--media-menu-overflow, hidden auto);
      display: flex;
      padding-block: .5em;
    }

    media-chrome-menu-item {
      padding-inline: .7em 1.4em;
    }

    media-chrome-menu-item > span {
      margin-inline: .5ch;
    }

    [part~="indicator"] {
      fill: var(--media-menu-item-indicator-fill, var(--media-icon-color, var(--media-primary-color, rgb(238 238 238))));
      height: var(--media-menu-item-indicator-height, 1.25em);
      vertical-align: var(--media-menu-item-indicator-vertical-align, text-top);
    }

    [part~="checked-indicator"] {
      display: var(--media-menu-item-checked-indicator-display);
      visibility: hidden;
    }

    [aria-checked="true"] > [part~="checked-indicator"] {
      visibility: visible;
    }
  </style>
  <style id="layout-row" media="width:0">

    ::slotted([slot="header"]) {
      padding: .4em .5em;
    }

    #container {
      gap: var(--media-menu-gap, .25em);
      flex-direction: var(--media-menu-flex-direction, row);
      padding-inline: .5em;
    }

    media-chrome-menu-item {
      padding: .3em .24em;
    }

    media-chrome-menu-item[aria-checked="true"] {
      background: var(--media-menu-item-checked-background, rgb(255 255 255 / .2));
    }

    [part~="checked-indicator"] {
      display: var(--media-menu-item-checked-indicator-display, none);
    }
  </style>
  <slot name="header"></slot>
  <slot id="container"></slot>
  <slot name="checked-indicator" hidden>${checkIcon}</slot>
`;
const Attributes = {
  STYLE: "style",
  HIDDEN: "hidden",
  DISABLED: "disabled",
  ANCHOR: "anchor"
};
class MediaChromeMenu extends import_server_safe_globals.globalThis.HTMLElement {
  constructor(options = {}) {
    super();
    __privateAdd(this, _updateLayoutStyle);
    __privateAdd(this, _handleInvoke);
    __privateAdd(this, _handleOpen);
    __privateAdd(this, _handleClosed);
    __privateAdd(this, _handleKeyUp);
    __privateAdd(this, _handleKeyDown);
    __privateAdd(this, _handleKeyListener);
    __privateAdd(this, _getItem);
    __privateAdd(this, _selectItem);
    __privateAdd(this, _handleClick);
    __privateAdd(this, _handleFocusOut);
    __privateAdd(this, _searchItem);
    __privateAdd(this, _clearKeysOnDelay);
    __privateAdd(this, _mediaController, void 0);
    __privateAdd(this, _previouslyFocused, void 0);
    __privateAdd(this, _invokerElement, void 0);
    __privateAdd(this, _keysSoFar, "");
    __privateAdd(this, _clearKeysTimeout, null);
    __privateAdd(this, _metaPressed, false);
    __privateAdd(this, _updateMenuPosition, () => {
      if (this.hasAttribute("mediacontroller") && !this.anchor)
        return;
      if (this.hidden || !this.anchorElement)
        return;
      const { x, y } = (0, import_anchor_utils.computePosition)({
        anchor: this.anchorElement,
        floating: this,
        placement: "top-start"
      });
      const bounds = getBoundsElement(this);
      const boundsRect = bounds.getBoundingClientRect();
      const anchorRect = this.anchorElement.getBoundingClientRect();
      const right = boundsRect.width - x - this.offsetWidth;
      const bottom = boundsRect.height - y - this.offsetHeight;
      const maxHeight = boundsRect.height - anchorRect.height;
      const { style } = (0, import_element_utils.getOrInsertCSSRule)(this.shadowRoot, ":host");
      style.setProperty("position", "absolute");
      style.setProperty("right", `${Math.max(0, right)}px`);
      style.setProperty("bottom", `${bottom}px`);
      style.setProperty("--_max-height", `${maxHeight}px`);
    });
    if (!this.shadowRoot) {
      this.attachShadow({ mode: "open" });
      this.nativeEl = template.content.cloneNode(true);
      if (options.slotTemplate) {
        this.nativeEl.append(options.slotTemplate.content.cloneNode(true));
      }
      this.shadowRoot.append(this.nativeEl);
    }
    this.container = this.shadowRoot.querySelector("#container");
    this.container.addEventListener("slotchange", (event) => {
      for (let node of event.target.assignedNodes({ flatten: true })) {
        if (node.nodeType === 3 && node.textContent.trim() === "") {
          node.remove();
        }
      }
    });
  }
  static get observedAttributes() {
    return [
      Attributes.DISABLED,
      Attributes.HIDDEN,
      Attributes.STYLE,
      Attributes.ANCHOR,
      import_constants.MediaStateReceiverAttributes.MEDIA_CONTROLLER
    ];
  }
  static formatMenuItemText(text) {
    return text;
  }
  enable() {
    this.addEventListener("click", this);
    this.addEventListener("focusout", this);
    this.addEventListener("keydown", this);
    this.addEventListener("invoke", this);
  }
  disable() {
    this.removeEventListener("click", this);
    this.removeEventListener("focusout", this);
    this.removeEventListener("keyup", this);
    this.removeEventListener("invoke", this);
  }
  handleEvent(event) {
    switch (event.type) {
      case "invoke":
        __privateMethod(this, _handleInvoke, handleInvoke_fn).call(this, event);
        break;
      case "click":
        __privateMethod(this, _handleClick, handleClick_fn).call(this, event);
        break;
      case "focusout":
        __privateMethod(this, _handleFocusOut, handleFocusOut_fn).call(this, event);
        break;
      case "keydown":
        __privateMethod(this, _handleKeyDown, handleKeyDown_fn).call(this, event);
        break;
      case "keyup":
        __privateMethod(this, _handleKeyUp, handleKeyUp_fn).call(this, event);
        break;
    }
  }
  connectedCallback() {
    var _a, _b;
    __privateMethod(this, _updateLayoutStyle, updateLayoutStyle_fn).call(this);
    if (!this.hasAttribute("disabled")) {
      this.enable();
    }
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "menu");
    }
    __privateSet(this, _mediaController, (0, import_element_utils.getAttributeMediaController)(this));
    (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.associateElement) == null ? void 0 : _b.call(_a, this);
    if (!this.hidden) {
      (0, import_resize_observer.observeResize)(getBoundsElement(this), __privateGet(this, _updateMenuPosition));
    }
  }
  disconnectedCallback() {
    var _a, _b;
    (0, import_resize_observer.unobserveResize)(getBoundsElement(this), __privateGet(this, _updateMenuPosition));
    this.disable();
    (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);
    __privateSet(this, _mediaController, null);
  }
  attributeChangedCallback(attrName, oldValue, newValue) {
    var _a, _b, _c, _d;
    if (attrName === Attributes.HIDDEN && newValue !== oldValue) {
      if (this.hidden) {
        __privateMethod(this, _handleClosed, handleClosed_fn).call(this);
      } else {
        __privateMethod(this, _handleOpen, handleOpen_fn).call(this);
      }
    } else if (attrName === import_constants.MediaStateReceiverAttributes.MEDIA_CONTROLLER) {
      if (oldValue) {
        (_b = (_a = __privateGet(this, _mediaController)) == null ? void 0 : _a.unassociateElement) == null ? void 0 : _b.call(_a, this);
        __privateSet(this, _mediaController, null);
      }
      if (newValue && this.isConnected) {
        __privateSet(this, _mediaController, (0, import_element_utils.getAttributeMediaController)(this));
        (_d = (_c = __privateGet(this, _mediaController)) == null ? void 0 : _c.associateElement) == null ? void 0 : _d.call(_c, this);
      }
    } else if (attrName === Attributes.DISABLED && newValue !== oldValue) {
      if (newValue == null) {
        this.enable();
      } else {
        this.disable();
      }
    } else if (attrName === Attributes.STYLE && newValue !== oldValue) {
      __privateMethod(this, _updateLayoutStyle, updateLayoutStyle_fn).call(this);
    }
  }
  formatMenuItemText(text, data) {
    return this.constructor.formatMenuItemText(text, data);
  }
  get keysUsed() {
    return ["Enter", "Escape", " ", "ArrowDown", "ArrowUp", "Home", "End"];
  }
  get anchor() {
    return this.getAttribute("anchor");
  }
  set anchor(value) {
    this.setAttribute("anchor", `${value}`);
  }
  get anchorElement() {
    var _a;
    if (this.anchor) {
      return (_a = (0, import_element_utils.getDocumentOrShadowRoot)(this)) == null ? void 0 : _a.querySelector(`#${this.anchor}`);
    }
    return null;
  }
  get items() {
    var _a;
    let items = this.querySelectorAll('[role^="menuitem"]');
    if (!items.length) {
      items = (_a = this.container) == null ? void 0 : _a.querySelectorAll('[role^="menuitem"]');
    }
    return Array.from(items);
  }
  get radioGroupItems() {
    return this.items.filter(
      (item) => item.getAttribute("role") === "menuitemradio"
    );
  }
  get checkedItems() {
    return this.items.filter((item) => item.checked);
  }
  get value() {
    var _a, _b;
    return (_b = (_a = this.checkedItems[0]) == null ? void 0 : _a.value) != null ? _b : "";
  }
  set value(newValue) {
    const item = this.items.find((item2) => item2.value === newValue);
    if (!item)
      return;
    __privateMethod(this, _selectItem, selectItem_fn).call(this, item);
  }
  focus() {
    var _a, _b, _c;
    __privateSet(this, _previouslyFocused, (0, import_element_utils.getActiveElement)());
    if (this.checkedItems.length) {
      (_a = this.checkedItems[0]) == null ? void 0 : _a.focus();
      return;
    }
    (_c = (_b = this.items) == null ? void 0 : _b[0]) == null ? void 0 : _c.focus();
  }
  handleSelection(event) {
    const item = __privateMethod(this, _getItem, getItem_fn).call(this, event);
    if (!item)
      return;
    __privateMethod(this, _selectItem, selectItem_fn).call(this, item, item.type === "checkbox");
    if (__privateGet(this, _invokerElement) && !this.hidden) {
      this.hidden = true;
    }
  }
  handleMovement(event) {
    const { key } = event;
    const els = this.items;
    let currentItem = __privateMethod(this, _getItem, getItem_fn).call(this, event);
    if (!currentItem) {
      currentItem = els.filter((el) => el.getAttribute("tabindex") === "0")[0];
    }
    let nextItem;
    switch (key) {
      case "ArrowDown":
        nextItem = currentItem.nextElementSibling;
        if (nextItem == null ? void 0 : nextItem.hasAttribute("disabled")) {
          nextItem = nextItem.nextElementSibling;
        }
        break;
      case "ArrowUp":
        nextItem = currentItem.previousElementSibling;
        if (nextItem == null ? void 0 : nextItem.hasAttribute("disabled")) {
          nextItem = nextItem.previousElementSibling;
        }
        break;
      case "Home":
        nextItem = els[0];
        break;
      case "End":
        nextItem = els[els.length - 1];
        break;
      default:
        nextItem = __privateMethod(this, _searchItem, searchItem_fn).call(this, key);
        break;
    }
    if (nextItem) {
      els.forEach((el) => el.setAttribute("tabindex", "-1"));
      nextItem.setAttribute("tabindex", "0");
      nextItem.focus();
    }
  }
}
_mediaController = new WeakMap();
_previouslyFocused = new WeakMap();
_invokerElement = new WeakMap();
_keysSoFar = new WeakMap();
_clearKeysTimeout = new WeakMap();
_metaPressed = new WeakMap();
_updateLayoutStyle = new WeakSet();
updateLayoutStyle_fn = function() {
  var _a;
  const layoutRowStyle = this.shadowRoot.querySelector("#layout-row");
  const menuLayout = (_a = getComputedStyle(this).getPropertyValue("--media-menu-layout")) == null ? void 0 : _a.trim();
  layoutRowStyle.setAttribute("media", menuLayout === "row" ? "" : "width:0");
};
_handleInvoke = new WeakSet();
handleInvoke_fn = function(event) {
  __privateSet(this, _invokerElement, event.relatedTarget);
  this.hidden = !this.hidden;
};
_handleOpen = new WeakSet();
handleOpen_fn = function() {
  var _a;
  (_a = __privateGet(this, _invokerElement)) == null ? void 0 : _a.setAttribute("aria-expanded", "true");
  requestAnimationFrame(() => __privateGet(this, _updateMenuPosition).call(this));
  this.focus();
  (0, import_resize_observer.observeResize)(getBoundsElement(this), __privateGet(this, _updateMenuPosition));
};
_handleClosed = new WeakSet();
handleClosed_fn = function() {
  var _a;
  (_a = __privateGet(this, _invokerElement)) == null ? void 0 : _a.setAttribute("aria-expanded", "false");
  (0, import_resize_observer.unobserveResize)(getBoundsElement(this), __privateGet(this, _updateMenuPosition));
};
_updateMenuPosition = new WeakMap();
_handleKeyUp = new WeakSet();
handleKeyUp_fn = function(event) {
  const { key } = event;
  if (key === "Escape") {
    this.hidden = true;
    this.removeEventListener("keyup", __privateMethod(this, _handleKeyUp, handleKeyUp_fn));
    return;
  }
  if (key === "Meta") {
    __privateSet(this, _metaPressed, false);
    return;
  }
  __privateMethod(this, _handleKeyListener, handleKeyListener_fn).call(this, event);
};
_handleKeyDown = new WeakSet();
handleKeyDown_fn = function(event) {
  const { key, altKey } = event;
  if (altKey) {
    this.removeEventListener("keyup", this);
    return;
  }
  if (key === "Meta") {
    __privateSet(this, _metaPressed, true);
    return;
  }
  if (this.keysUsed.includes(key)) {
    event.preventDefault();
  }
  if (__privateGet(this, _metaPressed) && this.keysUsed.includes(key)) {
    __privateMethod(this, _handleKeyListener, handleKeyListener_fn).call(this, event);
    return;
  }
  this.addEventListener("keyup", this, { once: true });
};
_handleKeyListener = new WeakSet();
handleKeyListener_fn = function(event) {
  const { key } = event;
  if (key === "Enter" || key === " ") {
    this.handleSelection(event);
  } else {
    this.handleMovement(event);
  }
};
_getItem = new WeakSet();
getItem_fn = function(event) {
  return event.composedPath().find((el) => {
    var _a;
    return ["menuitemradio", "menuitemcheckbox"].includes(
      (_a = el.getAttribute) == null ? void 0 : _a.call(el, "role")
    );
  });
};
_selectItem = new WeakSet();
selectItem_fn = function(item, toggle) {
  const oldCheckedItems = [...this.checkedItems];
  if (item.type === "radio") {
    this.radioGroupItems.forEach((el) => el.checked = false);
  }
  if (toggle) {
    item.checked = !item.checked;
  } else {
    item.checked = true;
  }
  if (this.checkedItems.some((opt, i) => opt != oldCheckedItems[i])) {
    this.dispatchEvent(
      new Event("change", { bubbles: true, composed: true })
    );
  }
};
_handleClick = new WeakSet();
handleClick_fn = function(event) {
  const item = __privateMethod(this, _getItem, getItem_fn).call(this, event);
  if (!item || item.hasAttribute("disabled"))
    return;
  this.items.forEach((el) => el.setAttribute("tabindex", "-1"));
  item.setAttribute("tabindex", "0");
  this.handleSelection(event);
};
_handleFocusOut = new WeakSet();
handleFocusOut_fn = function(event) {
  var _a;
  if (!(0, import_element_utils.containsComposedNode)(this, event.relatedTarget)) {
    (_a = __privateGet(this, _previouslyFocused)) == null ? void 0 : _a.focus();
  }
  if (__privateGet(this, _invokerElement) && __privateGet(this, _invokerElement) !== event.relatedTarget && !this.hidden) {
    this.hidden = true;
  }
};
_searchItem = new WeakSet();
searchItem_fn = function(key) {
  __privateMethod(this, _clearKeysOnDelay, clearKeysOnDelay_fn).call(this);
  const els = this.items;
  const activeIndex = els.findIndex(
    (el) => el.getAttribute("tabindex") === "0"
  );
  __privateSet(this, _keysSoFar, __privateGet(this, _keysSoFar) + key);
  const repeatedKey = __privateGet(this, _keysSoFar).split("").every((k) => k === key);
  const after = els.slice(activeIndex + (repeatedKey ? 1 : 0)).filter((el) => el.textContent.toLowerCase().startsWith(__privateGet(this, _keysSoFar)));
  const before = els.slice(0, activeIndex - (repeatedKey ? 1 : 0)).filter((el) => el.textContent.toLowerCase().startsWith(__privateGet(this, _keysSoFar)));
  let afterRepeated = [];
  let beforeRepeated = [];
  if (repeatedKey) {
    afterRepeated = els.slice(activeIndex + (repeatedKey ? 1 : 0)).filter((el) => el.textContent.startsWith(key));
    beforeRepeated = els.slice(0, activeIndex - (repeatedKey ? 1 : 0)).filter((el) => el.textContent.startsWith(key));
  }
  const returns = [...after, ...before, ...afterRepeated, ...beforeRepeated];
  return returns[0];
};
_clearKeysOnDelay = new WeakSet();
clearKeysOnDelay_fn = function() {
  clearTimeout(__privateGet(this, _clearKeysTimeout));
  __privateSet(this, _clearKeysTimeout, null);
  __privateSet(this, _clearKeysTimeout, setTimeout(() => {
    __privateSet(this, _keysSoFar, "");
    __privateSet(this, _clearKeysTimeout, null);
  }, 500));
};
function getBoundsElement(host) {
  var _a;
  return (_a = host.getAttribute("bounds") ? (0, import_element_utils.closestComposedNode)(host, `#${host.getAttribute("bounds")}`) : (0, import_element_utils.getMediaController)(host) || host.parentElement) != null ? _a : host;
}
if (!import_server_safe_globals.globalThis.customElements.get("media-chrome-menu")) {
  import_server_safe_globals.globalThis.customElements.define("media-chrome-menu", MediaChromeMenu);
}
var media_chrome_menu_default = MediaChromeMenu;
